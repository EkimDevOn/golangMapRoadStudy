
#### Sintaxe

Qual a utilidade de fun√ß√µes?
Abstrair funcionalidade
Reutiliza√ß√£o de c√≥digo
func (receiver) identifier(parameters) (returns) { code }
A diferen√ßa entre par√¢metros e argumentos:
Fun√ß√µes s√£o definidas com par√¢metros
Fun√ß√µes s√£o chamadas com argumentos
Tudo em Go √© pass by value.
Pass by reference, pass by copy, ... n√£o.
Par√¢metro pode ser ...vari√°dico.
Exemplos:
Fun√ß√£o b√°sica. 
Go Playground: https://play.golang.org/p/FebJblBenP


Fun√ß√£o que aceita um argumento.
Go Playground:
        https://play.golang.org/p/CE6Ij3U4QB


Fun√ß√£o com retorno.
Go Playground: https://play.golang.org/p/gKxwYe6btP


Fun√ß√£o com m√∫ltiplos retornos e par√¢metro vari√°dico.
Go Playground: https://play.golang.org/p/OcQ1wXwM2c
Mais um: https://play.golang.org/p/8wc2TA9xH_


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 2. Desenrolando (enumerando) uma slice

Quando temos uma slice, podemos passar os elementos individuais atrav√©s "deste..." operador.
Exemplos:
Desenrolando uma slice de ints com como argumento para a fun√ß√£o "soma" anterior
Go Playground: https://play.golang.org/p/k8O3__8UDa


Pode-se passar zero ou mais valores
Go Playground: https://play.golang.org/p/C238I9n7Vs


O par√¢metro vari√°dico deve ser o par√¢metro final ‚Üí ref/spec#Passing_arguments_to_..._parameters
Go Playground: https://play.golang.org/p/8wc2TA9xH_
N√£o roda: https://play.golang.org/p/2qTAnLWfgB


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 
Fun√ß√µes ‚Äì 3. Defer

Fun√ß√µes s√£o √≥timas pois tornam nosso c√≥digo modular. Podemos alterar partes do nosso programa sem afetar o resto!
Uma declara√ß√£o defer chama uma fun√ß√£o cuja execu√ß√£o ocorrer√° no momento em que a fun√ß√£o da qual ela faz parte finalizar.
Essa finaliza√ß√£o pode ocorrer devido a um return, ao fim do code block da fun√ß√£o, ou no caso de p√¢nico em uma goroutine correspondente.
"Deixa pra √∫ltima hora!"
ref/spec
Sempre usamos para fechar um arquivo ap√≥s abri-lo.

Go Playground: https://play.golang.org/p/sFj8arw0E_


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 4. M√©todos

Um m√©todo √© uma fun√ß√£o anexada a um tipo, m√©todo adicona funcionalidade especificamente a um type
Quando se anexa uma fun√ß√£o a um tipo, ela se torna um m√©todo desse tipo.
Pode-se anexar uma fun√ß√£o a um tipo utilizando seu receiver.
Utiliza√ß√£o: valor.m√©todo()
Exemplo: o tipo "pessoa" pode ter um m√©todo oibomdia()
Go Playground: https://go.dev/play/p/SVyzChOSeKY

Em Go (Golang), m√©todos s√£o fun√ß√µes que est√£o associadas a um tipo espec√≠fico, como uma struct ou um tipo definido pelo usu√°rio. Eles permitem que voc√™ defina comportamentos espec√≠ficos para esses tipos, semelhante √† orienta√ß√£o a objetos em outras linguagens.

Vamos explorar como m√©todos funcionam em Go:

Definindo um m√©todo
Para definir um m√©todo em Go, voc√™ precisa:

Associar o m√©todo a um tipo (geralmente uma struct).

Especificar um receptor (receiver) entre a palavra-chave func e o nome do m√©todo.

A sintaxe geral √©:

go
Copy
func (receptor Tipo) NomeDoMetodo(parametros) tipoDeRetorno {
    // Corpo do m√©todo
}
Exemplo b√°sico
Aqui est√° um exemplo simples de um m√©todo associado a uma struct:

go
Copy
package main

import "fmt"

// Definindo uma struct
type Retangulo struct {
    Largura float64
    Altura  float64
}

// M√©todo para calcular a √°rea do ret√¢ngulo
func (r Retangulo) Area() float64 {
    return r.Largura * r.Altura
}

func main() {
    // Criando uma inst√¢ncia de Retangulo
    ret := Retangulo{Largura: 10, Altura: 5}

    // Chamando o m√©todo Area
    fmt.Println("√Årea do ret√¢ngulo:", ret.Area())
}
Sa√≠da:

Copy
√Årea do ret√¢ngulo: 50
Explica√ß√£o:
O m√©todo Area est√° associado ao tipo Retangulo.

O receptor (r Retangulo) permite que o m√©todo acesse os campos da struct (Largura e Altura).

Receptores: Valor vs Ponteiro
Em Go, os m√©todos podem ter receptores de valor ou de ponteiro. Isso afeta como o m√©todo interage com a struct.

1. Receptor de valor
Uma c√≥pia da struct √© passada para o m√©todo.

Modifica√ß√µes feitas no m√©todo n√£o afetam a struct original.

Exemplo:

go
Copy
func (r Retangulo) SetLargura(novaLargura float64) {
    r.Largura = novaLargura // Isso n√£o afeta a struct original
}
2. Receptor de ponteiro
Um ponteiro para a struct √© passado para o m√©todo.

Modifica√ß√µes feitas no m√©todo afetam a struct original.

Exemplo:

go
Copy
func (r *Retangulo) SetLargura(novaLargura float64) {
    r.Largura = novaLargura // Isso afeta a struct original
}
Exemplo com receptor de ponteiro
Aqui est√° um exemplo que usa um receptor de ponteiro para modificar a struct original:

go
Copy
package main

import "fmt"

type Retangulo struct {
    Largura float64
    Altura  float64
}

// M√©todo com receptor de ponteiro
func (r *Retangulo) SetLargura(novaLargura float64) {
    r.Largura = novaLargura
}

func main() {
    ret := Retangulo{Largura: 10, Altura: 5}
    fmt.Println("Largura antes:", ret.Largura)

    // Modificando a largura usando o m√©todo
    ret.SetLargura(20)
    fmt.Println("Largura depois:", ret.Largura)
}
Sa√≠da:

Copy
Largura antes: 10
Largura depois: 20
M√©todos para tipos n√£o-struct
Em Go, voc√™ tamb√©m pode definir m√©todos para tipos que n√£o s√£o structs, desde que o tipo seja definido no mesmo pacote.

Exemplo:

go
Copy
package main

import "fmt"

// Definindo um tipo personalizado
type MeuInt int

// M√©todo para o tipo MeuInt
func (m MeuInt) Dobro() MeuInt {
    return m * 2
}

func main() {
    num := MeuInt(5)
    fmt.Println("Dobro de", num, "√©", num.Dobro())
}
Sa√≠da:

Copy
Dobro de 5 √© 10
M√©todos vs Fun√ß√µes
M√©todos: Est√£o associados a um tipo espec√≠fico e t√™m um receptor.

Fun√ß√µes: S√£o independentes e n√£o est√£o associadas a nenhum tipo.

Exemplo de fun√ß√£o equivalente ao m√©todo Area:


func Area(r Retangulo) float64 {
    return r.Largura * r.Altura
}
Resumo
M√©todos s√£o fun√ß√µes associadas a um tipo (struct ou tipo personalizado).

O receptor define o tipo ao qual o m√©todo pertence.

Receptores podem ser de valor (c√≥pia) ou de ponteiro (refer√™ncia).

M√©todos permitem adicionar comportamentos espec√≠ficos a tipos.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 5. Interfaces & polimorfismo

Em Go, valores podem ter mais que um tipo.
Uma interface permite que um valor tenha mais que um tipo.

Declara√ß√£o: keyword identifier type ‚Üí type x interface

Ap√≥s declarar a interface, deve-se definir os m√©todos necess√°rios para implementar essa interface.
Se um tipo possuir todos os m√©todos necess√°rios (que, no caso da interface{}, pode ser nenhum) ent√£o esse tipo implicitamente implementa a interface.
Esse tipo ser√° o seu tipo e tamb√©m o tipo da interface.

Exemplos:
Os tipos profiss√£o1 e profiss√£o2 contem o tipo pessoa
Cada um tem seu m√©todo oibomdia()*, e podem dar oi utilizando *pessoa.oibomdia()
Implementam a interface gente
Ambos podem acessar o fun√ß√£o serhumano() que chama o m√©todo oibomdia() de cada gente
Tambem podemos no m√©todo serhumano() tomar a√ß√µes diferentes dependendo do tipo:
        switch pessoa.(type) { case profiss√£o1: fmt.Println(h.(profiss√£o1).valorques√≥existeemprofiss√£o1) [...] }* 
Go Playground pr√©-pronto: https://play.golang.org/p/VLbo_1uE-U

https://play.golang.org/p/zGKr7cvTPF

Go Playground ao vivo:
    https://play.golang.org/p/njiKbTT20Cr
    
Onde se utiliza?
√Årea de formas geom√©tricas (gobyexample.com)
Sort
DB
Writer interface: arquivos locais, http request/resp

outro exemplo - https://go.dev/play/p/LRFd75a2os9

outro exemplo - https://go.dev/play/p/XLmQZaCm9Gv


link aula:
- https://youtu.be/2zTENBJTlD0?list=PLCKpcjBB_VlBsxJ9IseNxFllf-UFEXOdg

MAIS DETALHADO :

Em Go (Golang), interfaces e polimorfismo s√£o conceitos poderosos que permitem criar c√≥digo flex√≠vel e reutiliz√°vel. 
Vamos explorar como eles funcionam:

Interfaces
Uma interface em Go √© um tipo que define um conjunto de m√©todos. Qualquer tipo que implemente esses m√©todos implementa implicitamente a interface.
 Go n√£o tem heran√ßa cl√°ssica, mas as interfaces permitem um comportamento semelhante ao polimorfismo.

Sintaxe de uma interface:

type NomeDaInterface interface {
    Metodo1(parametros) tipoDeRetorno
    Metodo2(parametros) tipoDeRetorno
}
Exemplo b√°sico de interface
Aqui est√° um exemplo simples de uma interface Forma com um m√©todo Area():

////////////
package main

import (
    "fmt"
    "math"
)

// Definindo a interface
type Forma interface {
    Area() float64
}

// Definindo uma struct para um C√≠rculo
type Circulo struct {
    Raio float64
}

// Implementando o m√©todo Area para Circulo
func (c Circulo) Area() float64 {
    return math.Pi * c.Raio * c.Raio
}

// Definindo uma struct para um Ret√¢ngulo
type Retangulo struct {
    Largura float64
    Altura  float64
}

// Implementando o m√©todo Area para Retangulo
func (r Retangulo) Area() float64 {
    return r.Largura * r.Altura
}

// Fun√ß√£o que usa a interface Forma
func imprimirArea(f Forma) {
    fmt.Printf("A √°rea da forma √© %.2f\n", f.Area())
}

func main() {
    // Criando inst√¢ncias de Circulo e Retangulo
    circ := Circulo{Raio: 5}
    ret := Retangulo{Largura: 10, Altura: 5}

    // Usando a fun√ß√£o imprimirArea com diferentes formas
    imprimirArea(circ)
    imprimirArea(ret)
}
Sa√≠da:

Copy
A √°rea da forma √© 78.54
A √°rea da forma √© 50.00
Explica√ß√£o:
A interface Forma define um m√©todo Area().

Tanto Circulo quanto Retangulo implementam o m√©todo Area(), ent√£o eles implementam implicitamente a interface Forma.

A fun√ß√£o imprimirArea aceita qualquer tipo que implemente a interface Forma, demonstrando polimorfismo.

Polimorfismo
O polimorfismo em Go √© alcan√ßado atrav√©s de interfaces. Ele permite que voc√™ trate diferentes tipos de forma uniforme, 
desde que implementem a mesma interface.

No exemplo acima:

Circulo e Retangulo s√£o tipos diferentes, mas ambos implementam a interface Forma.

A fun√ß√£o imprimirArea pode aceitar qualquer um desses tipos, pois eles satisfazem a interface Forma.

Interface vazia (interface{})
A interface vazia (interface{}) n√£o tem m√©todos, o que significa que qualquer tipo a implementa. Isso √© √∫til quando voc√™ precisa de 
flexibilidade para trabalhar com tipos desconhecidos ou variados.

Exemplo:


func imprimirValor(valor interface{}) {
    fmt.Println(valor)
}

func main() {
    imprimirValor(42)         // int
    imprimirValor("Ol√°")      // string
    imprimirValor(3.14)       // float64
}
Sa√≠da:

Copy
42
Ol√°
3.14
Type Assertion
Quando voc√™ trabalha com interfaces (especialmente interface{}), pode ser necess√°rio extrair o valor subjacente de um tipo espec√≠fico. Isso √© feito com type assertion.

Exemplo:


func descobrirTipo(valor interface{}) {
    switch v := valor.(type) {
    case int:
        fmt.Println("√â um int:", v)
    case string:
        fmt.Println("√â uma string:", v)
    default:
        fmt.Println("Tipo desconhecido")
    }
}

func main() {
    descobrirTipo(42)
    descobrirTipo("Ol√°")
    descobrirTipo(3.14)
}
Sa√≠da:

Copy
√â um int: 42
√â uma string: Ol√°
Tipo desconhecido
Composi√ß√£o de interfaces
Em Go, voc√™ pode compor interfaces para criar novas interfaces. Isso permite combinar comportamentos de v√°rias interfaces.

Exemplo:


type Leitor interface {
    Ler() string
}

type Escritor interface {
    Escrever(texto string)
}

// Composi√ß√£o de interfaces
type LeitorEscritor interface {
    Leitor
    Escritor
}
Qualquer tipo que implemente Ler() e Escrever() automaticamente implementa LeitorEscritor.

Resumo
Interfaces definem um conjunto de m√©todos que um tipo deve implementar.

Polimorfismo √© alcan√ßado quando diferentes tipos implementam a mesma interface.

Interface vazia (interface{}) permite trabalhar com qualquer tipo.

Type assertion √© usado para extrair o valor subjacente de uma interface.

Composi√ß√£o de interfaces permite combinar comportamentos de v√°rias interfaces.

Interfaces e polimorfismo s√£o fundamentais para escrever c√≥digo flex√≠vel e reutiliz√°vel em Go.
Eles permitem que voc√™ crie abstra√ß√µes poderosas sem depender de heran√ßa complexa. üòä

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 6. Fun√ß√µes an√¥nimas


Anonymous self-executing functions ‚Üí Fun√ß√µes an√¥nimas auto-execut√°veis.
func(p params) { ... }()
Vamos ver bastante quando falarmos de goroutines.
Go Playground: https://play.golang.org/p/Rnqmo6X6jh 

Em Go (ou Golang), fun√ß√µes an√¥nimas s√£o fun√ß√µes que n√£o possuem um nome associado a elas. 
Elas s√£o √∫teis quando voc√™ precisa definir uma fun√ß√£o rapidamente, sem a necessidade de declar√°-la formalmente com um nome.
Fun√ß√µes an√¥nimas s√£o frequentemente usadas em situa√ß√µes onde voc√™ precisa passar uma fun√ß√£o como argumento para outra fun√ß√£o ou quando voc√™ quer definir uma fun√ß√£o diretamente no local onde ela ser√° usada.

Sintaxe b√°sica
A sintaxe para uma fun√ß√£o an√¥nima em Go √© a seguinte:


func(par√¢metros) tipo_de_retorno {
    // corpo da fun√ß√£o
}

Exemplo 2: Passando uma fun√ß√£o an√¥nima como argumento
Fun√ß√µes an√¥nimas podem ser passadas como argumentos para outras fun√ß√µes. Aqui est√° um exemplo onde uma fun√ß√£o an√¥nima √© passada para a fun√ß√£o fmt.Println:


package main

import "fmt"

func main() {
    // Passando uma fun√ß√£o an√¥nima como argumento
    fmt.Println(func() string {
        return "Ol√°, mundo!"
    }())
}
Neste exemplo, a fun√ß√£o an√¥nima retorna uma string que √© passada diretamente para fmt.Println.



Exemplo 3: Atribuindo uma fun√ß√£o an√¥nima a uma vari√°vel
Voc√™ tamb√©m pode atribuir uma fun√ß√£o an√¥nima a uma vari√°vel e cham√°-la posteriormente:


package main

import "fmt"

func main() {
    // Atribuindo uma fun√ß√£o an√¥nima a uma vari√°vel
    saudacao := func() {
        fmt.Println("Ol√°, mundo!")
    }

    // Chamando a fun√ß√£o an√¥nima atrav√©s da vari√°vel
    saudacao()
}
Neste exemplo, a fun√ß√£o an√¥nima √© atribu√≠da √† vari√°vel saudacao, que pode ser chamada como uma fun√ß√£o normal.



Exemplo 4: Fun√ß√£o an√¥nima com par√¢metros
Fun√ß√µes an√¥nimas tamb√©m podem receber par√¢metros:


package main

import "fmt"

func main() {
    // Fun√ß√£o an√¥nima com par√¢metros
    soma := func(a, b int) int {
        return a + b
    }

    resultado := soma(3, 4)
    fmt.Println("Resultado da soma:", resultado)
}
Neste exemplo, a fun√ß√£o an√¥nima recebe dois par√¢metros inteiros e retorna a soma deles.



Exemplo 5: Fun√ß√£o an√¥nima em uma goroutine
Fun√ß√µes an√¥nimas s√£o frequentemente usadas em goroutines para executar c√≥digo concorrentemente:


package main

import (
    "fmt"
    "time"
)

func main() {
    // Fun√ß√£o an√¥nima em uma goroutine
    go func() {
        fmt.Println("Executando em uma goroutine")
    }()

    // Dando tempo para a goroutine executar
    time.Sleep(1 * time.Second)
    fmt.Println("Fun√ß√£o main terminando")
}
Neste exemplo, a fun√ß√£o an√¥nima √© executada em uma goroutine separada, permitindo que o c√≥digo seja executado concorrentemente com a fun√ß√£o main.

Conclus√£o
Fun√ß√µes an√¥nimas em Go s√£o uma ferramenta poderosa e flex√≠vel que permite definir fun√ß√µes rapidamente e us√°-las em contextos onde uma fun√ß√£o formal n√£o √© necess√°ria.
 Elas s√£o especialmente √∫teis em situa√ß√µes como callbacks, goroutines, e quando voc√™ precisa de uma fun√ß√£o tempor√°ria ou de curta dura√ß√£o.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 7. Func como express√£o

f := func(p params){ ... }
f()
Go Playground: https://play.golang.org/p/cPxhPUbfLy


Em Go, fun√ß√µes s√£o cidad√£os de primeira classe, o que significa que voc√™ pode trat√°-las como qualquer outro valor.
 Isso inclui atribuir fun√ß√µes a vari√°veis, pass√°-las como argumentos para outras fun√ß√µes, retorn√°-las de fun√ß√µes e at√© mesmo definir fun√ß√µes como express√µes. Quando falamos de "fun√ß√£o como express√£o", 
 estamos nos referindo √† capacidade de definir uma fun√ß√£o diretamente como parte de uma express√£o, sem precisar declar√°-la com um nome.

O que √© uma fun√ß√£o como express√£o?
Uma fun√ß√£o como express√£o √© basicamente uma fun√ß√£o an√¥nima que pode ser usada diretamente em um contexto onde uma express√£o √© esperada.
 Isso permite que voc√™ crie fun√ß√µes "on-the-fly" e as use imediatamente.

Exemplo b√°sico de fun√ß√£o como express√£o
Aqui est√° um exemplo simples de como voc√™ pode usar uma fun√ß√£o como express√£o:


package main

import "fmt"

func main() {
    // Atribuindo uma fun√ß√£o an√¥nima (express√£o) a uma vari√°vel
    soma := func(a, b int) int {
        return a + b
    }

    // Usando a fun√ß√£o armazenada na vari√°vel
    resultado := soma(3, 4)
    fmt.Println("Resultado da soma:", resultado) // Resultado: 7
}
Neste exemplo:

A fun√ß√£o an√¥nima func(a, b int) int √© definida como uma express√£o.

Ela √© atribu√≠da √† vari√°vel soma.

A vari√°vel soma pode ser chamada como uma fun√ß√£o normal.


Passando fun√ß√µes como argumentos
Uma fun√ß√£o como express√£o pode ser passada diretamente como argumento para outra fun√ß√£o. Isso √© comum em fun√ß√µes de alta ordem, como map, filter, etc. 
(embora Go n√£o tenha essas fun√ß√µes built-in, voc√™ pode implement√°-las).

Aqui est√° um exemplo:


package main

import "fmt"

// Fun√ß√£o que aceita outra fun√ß√£o como argumento
func aplicarFuncao(a, b int, funcao func(int, int) int) int {
    return funcao(a, b)
}

func main() {
    // Passando uma fun√ß√£o como express√£o
    resultado := aplicarFuncao(5, 3, func(x, y int) int {
        return x * y
    })

    fmt.Println("Resultado da multiplica√ß√£o:", resultado) // Resultado: 15
}
Neste exemplo:

A fun√ß√£o aplicarFuncao recebe uma fun√ß√£o como terceiro argumento.

Passamos uma fun√ß√£o an√¥nima func(x, y int) int diretamente como argumento.



Retornando fun√ß√µes como express√£o
Voc√™ tamb√©m pode retornar uma fun√ß√£o como express√£o de outra fun√ß√£o. Isso √© √∫til para criar closures (fun√ß√µes que capturam vari√°veis do contexto em que foram definidas).

Aqui est√° um exemplo:


package main

import "fmt"

// Fun√ß√£o que retorna outra fun√ß√£o
func criarMultiplicador(fator int) func(int) int {
    return func(x int) int {
        return x * fator
    }
}

func main() {
    // Criando uma fun√ß√£o multiplicadora
    dobrar := criarMultiplicador(2)
    triplicar := criarMultiplicador(3)

    // Usando as fun√ß√µes retornadas
    fmt.Println("Dobrar 5:", dobrar(5))      // Resultado: 10
    fmt.Println("Triplicar 5:", triplicar(5)) // Resultado: 15
}
Neste exemplo:

A fun√ß√£o criarMultiplicador retorna uma fun√ß√£o an√¥nima que multiplica um n√∫mero pelo fator passado.

As fun√ß√µes dobrar e triplicar s√£o criadas chamando criarMultiplicador com diferentes fatores.



Fun√ß√£o como express√£o em goroutines
Fun√ß√µes como express√£o tamb√©m s√£o √∫teis em goroutines, onde voc√™ pode definir uma fun√ß√£o diretamente no local onde ela ser√° executada de forma concorrente.

Aqui est√° um exemplo:


package main

import (
    "fmt"
    "time"
)

func main() {
    // Executando uma fun√ß√£o como express√£o em uma goroutine
    go func() {
        fmt.Println("Executando em uma goroutine")
    }()

    // Dando tempo para a goroutine executar
    time.Sleep(1 * time.Second)
    fmt.Println("Fun√ß√£o main terminando")
}
Neste exemplo:

A fun√ß√£o an√¥nima √© definida e executada imediatamente em uma goroutine.

O time.Sleep √© usado para garantir que a goroutine tenha tempo de executar antes do programa terminar.

Resumo
Fun√ß√£o como express√£o √© uma fun√ß√£o an√¥nima que pode ser usada diretamente em um contexto onde uma express√£o √© esperada.

Ela pode ser atribu√≠da a vari√°veis, passada como argumento para outras fun√ß√µes, retornada de fun√ß√µes ou usada em goroutines.

Isso torna o c√≥digo mais conciso e flex√≠vel, especialmente em situa√ß√µes onde voc√™ precisa de uma fun√ß√£o tempor√°ria ou espec√≠fica para um contexto.


Essa abordagem √© uma das caracter√≠sticas poderosas de Go, permitindo que voc√™ escreva c√≥digo funcional e modular de maneira eficiente.


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 8. Retornando uma fun√ß√£o

Pode-se usar uma fun√ß√£o como retorno de uma fun√ß√£o
Declara√ß√£o: func f() return
Exemplo: func f() func() int { [...]; return func() int{ return [int] } }
????: fmt.Println(f()())
Go Playground: https://play.golang.org/p/zPjoWNrCJF

Em Go, √© poss√≠vel retornar uma fun√ß√£o de outra fun√ß√£o. Isso √© uma caracter√≠stica poderosa da linguagem, que permite criar fun√ß√µes de alta ordem,
 closures e implementar padr√µes como f√°bricas de fun√ß√µes ou decoradores. Quando uma fun√ß√£o retorna outra fun√ß√£o, a fun√ß√£o retornada pode "capturar" vari√°veis do contexto em que foi criada, 
 o que √© conhecido como closure.

Como funciona?
Uma fun√ß√£o pode retornar outra fun√ß√£o como seu valor de retorno.

A fun√ß√£o retornada pode ser chamada posteriormente.

A fun√ß√£o retornada pode acessar e "lembrar" vari√°veis do escopo onde foi definida (closure).

Exemplo b√°sico: Retornando uma fun√ß√£o
Aqui est√° um exemplo simples de uma fun√ß√£o que retorna outra fun√ß√£o:


package main

import "fmt"

// Fun√ß√£o que retorna uma fun√ß√£o
func criarSaudacao(saudacao string) func(string) string {
    // Retorna uma fun√ß√£o an√¥nima
    return func(nome string) string {        //A fun√ß√£o an√¥nima captura a vari√°vel saudacao do escopo externo (closure).
        return saudacao + ", " + nome + "!"
    }
}

func main() {
    // Criando uma fun√ß√£o de sauda√ß√£o
    saudarEmPortugues := criarSaudacao("Ol√°")
    saudarEmIngles := criarSaudacao("Hello")

    // Usando as fun√ß√µes retornadas
    fmt.Println(saudarEmPortugues("Jo√£o")) // Sa√≠da: Ol√°, Jo√£o!
    fmt.Println(saudarEmIngles("Mary"))    // Sa√≠da: Hello, Mary!
}

Explica√ß√£o:
A fun√ß√£o criarSaudacao recebe uma string saudacao e retorna uma fun√ß√£o an√¥nima.

A fun√ß√£o an√¥nima captura a vari√°vel saudacao do escopo externo (closure).

Quando chamamos criarSaudacao("Ol√°"), ela retorna uma fun√ß√£o que sempre usar√° "Ol√°" como sauda√ß√£o.

Podemos criar diferentes fun√ß√µes de sauda√ß√£o (saudarEmPortugues, saudarEmIngles) com base no argumento passado para criarSaudacao.


Exemplo 2: Fun√ß√£o que retorna uma fun√ß√£o para c√°lculos
Vamos criar uma fun√ß√£o que retorna uma fun√ß√£o para realizar opera√ß√µes matem√°ticas:


package main

import "fmt"

// Fun√ß√£o que retorna uma fun√ß√£o para multiplicar
func criarMultiplicador(fator int) func(int) int {
    return func(x int) int {
        return x * fator
    }
}

func main() {
    // Criando fun√ß√µes multiplicadoras
    dobrar := criarMultiplicador(2)
    triplicar := criarMultiplicador(3)

    // Usando as fun√ß√µes retornadas
    fmt.Println("Dobrar 5:", dobrar(5))      // Sa√≠da: 10
    fmt.Println("Triplicar 5:", triplicar(5)) // Sa√≠da: 15
}

Explica√ß√£o:
A fun√ß√£o criarMultiplicador retorna uma fun√ß√£o que multiplica um n√∫mero pelo fator passado.

As fun√ß√µes dobrar e triplicar s√£o criadas chamando criarMultiplicador com diferentes fatores.

Essas fun√ß√µes "lembram" o valor de fator mesmo ap√≥s criarMultiplicador ter terminado sua execu√ß√£o (closure).



Exemplo 3: Closure com vari√°veis capturadas
Um dos usos mais poderosos de retornar fun√ß√µes √© a capacidade de criar closures, onde a fun√ß√£o retornada captura e mant√©m o estado das vari√°veis do escopo externo.

Aqui est√° um exemplo:


package main

import "fmt"

// Fun√ß√£o que retorna uma fun√ß√£o para contar
func criarContador() func() int {
    contador := 0 // Vari√°vel capturada pela closure
    return func() int {
        contador++
        return contador
    }
}

func main() {
    // Criando um contador
    contar := criarContador()

    // Usando a fun√ß√£o retornada
    fmt.Println(contar()) // Sa√≠da: 1
    fmt.Println(contar()) // Sa√≠da: 2
    fmt.Println(contar()) // Sa√≠da: 3

    // Criando outro contador independente
    outroContador := criarContador()
    fmt.Println(outroContador()) // Sa√≠da: 1
    fmt.Println(outroContador()) // Sa√≠da: 2
}

Explica√ß√£o:

A fun√ß√£o criarContador retorna uma fun√ß√£o que incrementa e retorna o valor de contador.

A vari√°vel contador √© capturada pela fun√ß√£o an√¥nima (closure), mantendo seu estado entre as chamadas.

Cada chamada de criarContador cria um novo escopo e uma nova vari√°vel contador, permitindo contadores independentes.


Exemplo 4: Fun√ß√£o que retorna uma fun√ß√£o para filtragem
Podemos usar fun√ß√µes que retornam fun√ß√µes para criar filtros personalizados:


package main

import "fmt"

// Fun√ß√£o que retorna uma fun√ß√£o de filtro
func criarFiltro(limite int) func(int) bool {
    return func(x int) bool {
        return x > limite
    }
}

func main() {
    // Criando um filtro para n√∫meros maiores que 10
    filtroMaiorQue10 := criarFiltro(10)

    // Usando o filtro
    numeros := []int{5, 12, 8, 15, 3, 20}
    for _, num := range numeros {
        if filtroMaiorQue10(num) {
            fmt.Println(num) // Sa√≠da: 12, 15, 20
        }
    }
}

Explica√ß√£o:
A fun√ß√£o criarFiltro retorna uma fun√ß√£o que verifica se um n√∫mero √© maior que um limite.

Podemos criar diferentes filtros com base no valor de limite.


Quando usar fun√ß√µes que retornam fun√ß√µes?

Closures: Para criar fun√ß√µes que "lembram" vari√°veis do escopo onde foram definidas.

F√°bricas de fun√ß√µes: Para gerar fun√ß√µes personalizadas com base em par√¢metros.

Decoradores: Para adicionar comportamentos extras a fun√ß√µes existentes.

Callbacks: Para passar fun√ß√µes como argumentos ou retorn√°-las como resultados.

Resumo

Em Go, voc√™ pode retornar uma fun√ß√£o de outra fun√ß√£o.

A fun√ß√£o retornada pode capturar vari√°veis do escopo onde foi definida (closure).

Isso √© √∫til para criar fun√ß√µes personalizadas, f√°bricas de fun√ß√µes, closures e muito mais.

Retornar fun√ß√µes √© uma t√©cnica poderosa que permite escrever c√≥digo modular, reutiliz√°vel e expressivo.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 9. Callback

Primeiro veja se voc√™ entende isso: https://play.golang.org/p/QkAtwMZU-z
Callback √© passar uma fun√ß√£o como argumento.
Exemplo:
Criando uma fun√ß√£o que toma uma fun√ß√£o e um []int, e usa somente os n√∫meros pares como argumentos para a fun√ß√£o.
Go Playground:
Desafio: Crie uma fun√ß√£o no programa acima que utilize somente os n√∫meros √≠mpares.

Em programa√ß√£o, um callback √© uma fun√ß√£o que √© passada como argumento para outra fun√ß√£o e √© executada ap√≥s a conclus√£o de uma opera√ß√£o ou em resposta a um evento. Em Go, como as fun√ß√µes s√£o cidad√£os de primeira classe, voc√™ pode passar fun√ß√µes como argumentos para outras fun√ß√µes, tornando os callbacks uma t√©cnica comum e poderosa.

O que √© um Callback?
Um callback √© uma fun√ß√£o que:

√â passada como argumento para outra fun√ß√£o.

√â chamada (ou "executada de volta") em algum momento durante a execu√ß√£o da fun√ß√£o que a recebeu.

Pode ser usada para personalizar o comportamento de uma fun√ß√£o ou para lidar com resultados ass√≠ncronos.

Exemplo b√°sico de Callback
Aqui est√° um exemplo simples de como usar um callback em Go:


package main

import "fmt"

// Fun√ß√£o que aceita um callback como argumento
func processar(n int, callback func(int)) {
    resultado := n * 2
    callback(resultado) // Chamando o callback
}

func main() {
    // Definindo um callback
    meuCallback := func(resultado int) {
        fmt.Println("Resultado processado:", resultado)
    }

    // Passando o callback para a fun√ß√£o processar
    processar(5, meuCallback) // Sa√≠da: Resultado processado: 10
}

Explica√ß√£o:
A fun√ß√£o processar recebe um n√∫mero inteiro n e uma fun√ß√£o callback como argumentos.

Dentro de processar, o n√∫mero √© processado (multiplicado por 2) e o resultado √© passado para o callback.

O callback √© chamado com o resultado, permitindo personalizar o que acontece com o resultado processado.

Exemplo 2: Callback com m√∫ltiplos par√¢metros
Callbacks podem receber m√∫ltiplos par√¢metros, permitindo maior flexibilidade:


package main

import "fmt"

// Fun√ß√£o que aceita um callback com m√∫ltiplos par√¢metros
func calcular(a, b int, callback func(int, int) int) int {
    return callback(a, b) // Chamando o callback e retornando o resultado
}

func main() {
    // Definindo um callback para soma
    soma := func(x, y int) int {
        return x + y
    }

    // Definindo um callback para multiplica√ß√£o
    multiplicacao := func(x, y int) int {
        return x * y
    }

    // Usando os callbacks
    resultadoSoma := calcular(3, 4, soma)
    resultadoMultiplicacao := calcular(3, 4, multiplicacao)

    fmt.Println("Soma:", resultadoSoma)             // Sa√≠da: 7
    fmt.Println("Multiplica√ß√£o:", resultadoMultiplicacao) // Sa√≠da: 12
}

Explica√ß√£o:
A fun√ß√£o calcular recebe dois n√∫meros e um callback que realiza uma opera√ß√£o com esses n√∫meros.

Diferentes callbacks (soma e multiplicacao) podem ser passados para personalizar o comportamento da fun√ß√£o calcular.


Exemplo 3: Callback para opera√ß√µes ass√≠ncronas
Callbacks s√£o frequentemente usados em opera√ß√µes ass√≠ncronas, como chamadas de rede ou leitura de arquivos. Aqui est√° um exemplo simulado:


package main

import (
    "fmt"
    "time"
)

// Fun√ß√£o que simula uma opera√ß√£o ass√≠ncrona com callback
func a(operacaoAssincroncallback func(string)) {
    go func() {
        // Simulando uma opera√ß√£o demorada
        time.Sleep(2 * time.Second)
        callback("Opera√ß√£o conclu√≠da!")
    }()
}

func main() {
    fmt.Println("Iniciando opera√ß√£o ass√≠ncrona...")

    // Passando um callback para ser executado ap√≥s a opera√ß√£o
    operacaoAssincrona(func(mensagem string) {
        fmt.Println(mensagem) // Sa√≠da: Opera√ß√£o conclu√≠da!
    })

    // Dando tempo para a opera√ß√£o ass√≠ncrona terminar
    time.Sleep(3 * time.Second)
}

Explica√ß√£o:
A fun√ß√£o operacaoAssincrona simula uma opera√ß√£o demorada usando time.Sleep.

Um callback √© passado para ser executado ap√≥s a conclus√£o da opera√ß√£o.

O callback √© chamado dentro de uma goroutine, permitindo que a fun√ß√£o principal continue sua execu√ß√£o sem bloquear.

Exemplo 4: Callback para tratamento de erros
Callbacks tamb√©m podem ser usados para lidar com erros ou resultados de opera√ß√µes que podem falhar:


package main

import (
    "errors"
    "fmt"
)

// Fun√ß√£o que simula uma opera√ß√£o que pode falhar
func operacaoComErro(callback func(int, error)) {
    sucesso := false // Simulando uma opera√ß√£o que pode falhar
    if sucesso {
        callback(42, nil) // Sucesso
    } else {
        callback(0, errors.New("Algo deu errado")) // Erro
    }
}

func main() {
    // Passando um callback para lidar com o resultado ou erro
    operacaoComErro(func(resultado int, err error) {
        if err != nil {
            fmt.Println("Erro:", err)
        } else {
            fmt.Println("Resultado:", resultado)
        }
    })
}

Explica√ß√£o:
A fun√ß√£o operacaoComErro simula uma opera√ß√£o que pode falhar.

O callback recebe dois par√¢metros: o resultado (se bem-sucedido) e um erro (se falhar).

O callback √© respons√°vel por lidar com o resultado ou o erro.

Quando usar Callbacks?
Opera√ß√µes ass√≠ncronas: Para lidar com resultados de opera√ß√µes que levam tempo, como chamadas de rede ou leitura de arquivos.

Personaliza√ß√£o de comportamento: Para permitir que o chamador personalize o comportamento de uma fun√ß√£o.

Tratamento de erros: Para lidar com erros ou resultados de opera√ß√µes que podem falhar.

Eventos: Para responder a eventos, como cliques de bot√£o em interfaces gr√°ficas (embora Go n√£o seja comumente usado para interfaces gr√°ficas).

Resumo
Um callback √© uma fun√ß√£o passada como argumento para outra fun√ß√£o e executada em algum momento.

Em Go, callbacks s√£o comuns devido ao suporte a fun√ß√µes como cidad√£os de primeira classe.

Callbacks s√£o √∫teis para opera√ß√µes ass√≠ncronas, personaliza√ß√£o de comportamento e tratamento de erros.

Eles permitem escrever c√≥digo modular, reutiliz√°vel e flex√≠vel.

Callbacks s√£o uma t√©cnica fundamental em programa√ß√£o funcional e s√£o amplamente utilizados em Go para criar c√≥digo mais expressivo e poderoso.


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


Fun√ß√µes ‚Äì 10. Closure

Closure √© cercar ou capturar um scope para que possamos utiliz√°-lo em outro contexto. J√° vimos:
Package-level scope
Function-level scope
Code-block-in-code-block scope
Exemplo de closure:
func i() func() int { x := 0; return func() int { x++; return x } }
Quando fizermos a := i() teremos um scope, um valor para x.
Quando fizermos b := i() teremos outro scope, e x ter√° um valor independente do x acima.
Closures nos permitem salvar dados entre function calls e ao mesmo tempo isolar estes dados do resto do c√≥digo.
Go Playground: https://play.golang.org/p/AdFciYwI2Z

aula - https://youtu.be/mOM0qTB5ppU?list=PLCKpcjBB_VlBsxJ9IseNxFllf-UFEXOdg


Em Go, uma closure √© uma fun√ß√£o que "captura" e mant√©m refer√™ncias a vari√°veis do escopo em que foi definida, mesmo ap√≥s o escopo ter sido encerrado.
Isso permite que a fun√ß√£o "lembre" do ambiente em que foi criada, incluindo vari√°veis locais, e as use mesmo quando executada em um contexto diferente.

O que √© uma Closure?
Uma closure √© uma fun√ß√£o que:

Captura vari√°veis: A fun√ß√£o pode acessar vari√°veis do escopo externo onde foi definida.

Mant√©m o estado: As vari√°veis capturadas mant√™m seu estado entre chamadas da fun√ß√£o.

√â autossuficiente: A fun√ß√£o pode ser passada para outros contextos e ainda acessar as vari√°veis capturadas.

Exemplo b√°sico de Closure
Aqui est√° um exemplo simples de uma closure em Go:


package main

import "fmt"

func main() {
    // Vari√°vel no escopo da fun√ß√£o main
    contador := 0

    // Closure: fun√ß√£o an√¥nima que captura a vari√°vel contador
    incrementar := func() int {
        contador++
        return contador
    }

    // Usando a closure
    fmt.Println(incrementar()) // Sa√≠da: 1
    fmt.Println(incrementar()) // Sa√≠da: 2
    fmt.Println(incrementar()) // Sa√≠da: 3
}
Explica√ß√£o:
A vari√°vel contador √© definida no escopo da fun√ß√£o main.

A fun√ß√£o an√¥nima incrementar captura a vari√°vel contador e a incrementa a cada chamada.

Mesmo ap√≥s o escopo da fun√ß√£o main ter sido encerrado, a closure incrementar ainda pode acessar e modificar contador.

Exemplo 2: Closure com m√∫ltiplas vari√°veis capturadas
Uma closure pode capturar m√∫ltiplas vari√°veis do escopo externo:


package main

import "fmt"

func main() {
    x := 10
    y := 5

    // Closure que captura x e y
    soma := func() int {
        return x + y
    }

    fmt.Println("Soma:", soma()) // Sa√≠da: 15

    // Modificando as vari√°veis capturadas
    x = 20
    y = 30
    fmt.Println("Soma atualizada:", soma()) // Sa√≠da: 50
}
Explica√ß√£o:
A closure soma captura as vari√°veis x e y.

Quando x e y s√£o modificados, a closure reflete essas mudan√ßas em sua execu√ß√£o.

Exemplo 3: Closure em fun√ß√µes que retornam fun√ß√µes
Um dos usos mais comuns de closures √© em fun√ß√µes que retornam outras fun√ß√µes. A fun√ß√£o retornada pode capturar 
vari√°veis do escopo da fun√ß√£o externa.

Aqui est√° um exemplo:


package main

import "fmt"

// Fun√ß√£o que retorna uma closure
func criarContador() func() int {
    contador := 0 // Vari√°vel capturada pela closure
    return func() int {
        contador++
        return contador
    }
}

func main() {
    // Criando uma closure
    contar := criarContador()

    // Usando a closure
    fmt.Println(contar()) // Sa√≠da: 1
    fmt.Println(contar()) // Sa√≠da: 2
    fmt.Println(contar()) // Sa√≠da: 3

    // Criando outra closure independente
    outroContador := criarContador()
    fmt.Println(outroContador()) // Sa√≠da: 1
    fmt.Println(outroContador()) // Sa√≠da: 2
}
Explica√ß√£o:
A fun√ß√£o criarContador retorna uma fun√ß√£o an√¥nima que captura a vari√°vel contador.

Cada chamada de criarContador cria um novo escopo e uma nova vari√°vel contador, permitindo contadores independentes.

Exemplo 4: Closure com par√¢metros
Closures tamb√©m podem receber par√¢metros, al√©m de capturar vari√°veis do escopo externo:


package main

import "fmt"

func main() {
    // Closure com par√¢metros
    multiplicador := func(fator int) func(int) int {
        return func(x int) int {
            return x * fator
        }
    }

    // Criando uma fun√ß√£o para dobrar n√∫meros
    dobrar := multiplicador(2)

    // Usando a closure
    fmt.Println("Dobrar 5:", dobrar(5)) // Sa√≠da: 10
    fmt.Println("Dobrar 10:", dobrar(10)) // Sa√≠da: 20
}
Explica√ß√£o:
A closure multiplicador captura o par√¢metro fator e retorna uma fun√ß√£o que multiplica um n√∫mero por fator.

A fun√ß√£o dobrar √© criada chamando multiplicador(2) e pode ser usada para dobrar n√∫meros.

Exemplo 5: Closure em goroutines
Closures s√£o frequentemente usadas em goroutines para capturar vari√°veis do escopo externo:


package main

import (
    "fmt"
    "time"
)

func main() {
    mensagem := "Ol√°, mundo!"

    // Executando uma closure em uma goroutine
    go func() {
        fmt.Println(mensagem) // Captura a vari√°vel mensagem
    }()

    // Dando tempo para a goroutine executar
    time.Sleep(1 * time.Second)
}

Explica√ß√£o:

A closure captura a vari√°vel mensagem do escopo da fun√ß√£o main.

A goroutine executa a closure, que imprime a mensagem capturada.

Quando usar Closures?
Manter estado: Para criar fun√ß√µes que "lembram" valores entre chamadas.

F√°bricas de fun√ß√µes: Para gerar fun√ß√µes personalizadas com base em par√¢metros.

Callbacks: Para passar fun√ß√µes que precisam acessar vari√°veis do escopo atual.

Goroutines: Para capturar vari√°veis e us√°-las em execu√ß√µes concorrentes.

Resumo:

Uma closure √© uma fun√ß√£o que captura e mant√©m refer√™ncias a vari√°veis do escopo em que foi definida.

Em Go, closures s√£o criadas usando fun√ß√µes an√¥nimas que acessam vari√°veis do escopo externo.

Closures s√£o √∫teis para manter estado, criar f√°bricas de fun√ß√µes, implementar callbacks e trabalhar com goroutines.

Elas permitem escrever c√≥digo modular, flex√≠vel e poderoso, especialmente em cen√°rios onde o estado precisa ser preservado entre chamadas de fun√ß√£o.

Closures s√£o uma das caracter√≠sticas mais poderosas de Go, permitindo que voc√™ escreva c√≥digo funcional e expressivo.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Fun√ß√µes ‚Äì 11. Recursividade

WP: "The most common application of recursion is in mathematics and computer science, where a function being defined is applied within its own definition."
Exemplos de recursividade: Fractais, matrioscas, efeito Droste (o efeito produzido por uma imagem que aparece dentro dela pr√≥pria), GNU (‚ÄúGNU is Not Unix‚Äù), etc.
No estudo de fun√ß√µes: √© uma fun√ß√£o que chama a ela pr√≥pria.
Exemplo: fatoriais.
4! = 4 * 3 * 2 * 1 (e no zero, deu.)

Com recursividade. Go Playground: https://play.golang.org/p/ujsLnUhRp_

Com loops. Go Playground: https://play.golang.org/p/F2VsUjYVhc


//** Tem momentos que vc vai querer usar fun√ß√µes recursivas, para todos os outros use LOOPS, pois toman menos mem√≥ria e tbm menos chances de erro.

 

A recursividade √© um conceito em programa√ß√£o onde uma fun√ß√£o chama a si mesma para resolver um problema. Em Go (Golang), 
assim como em outras linguagens de programa√ß√£o, a recursividade pode ser usada para resolver problemas que podem ser divididos em 
subproblemas menores e similares.

Aqui est√° um exemplo b√°sico de uma fun√ß√£o recursiva em Go que calcula o fatorial de um n√∫mero:


package main

import "fmt"

// Fun√ß√£o recursiva para calcular o fatorial de um n√∫mero
func factorial(n int) int {
    // Caso base: se n for 0 ou 1, o fatorial √© 1
    if n == 0 || n == 1 {
        return 1
    }
    // Chamada recursiva: n * fatorial de (n-1)
    return n * factorial(n-1)
}

func main() {
    num := 5
    fmt.Printf("O fatorial de %d √© %d\n", num, factorial(num))
}

Explica√ß√£o:

Caso base: A fun√ß√£o factorial tem um caso base que verifica se n √© 0 ou 1. Se for, a fun√ß√£o retorna 1, pois o fatorial de 0 e 1 √© 1.

Chamada recursiva: Se n for maior que 1, a fun√ß√£o chama a si mesma com n-1 e multiplica o resultado por n. Isso continua at√© que o 
caso base seja alcan√ßado.


Outro exemplo: Soma de n√∫meros em uma lista
Aqui est√° outro exemplo de uma fun√ß√£o recursiva que soma todos os n√∫meros em uma lista:


package main

import "fmt"

// Fun√ß√£o recursiva para somar os n√∫meros em uma lista
func sumList(nums []int) int {
    // Caso base: se a lista estiver vazia, retorna 0
    if len(nums) == 0 {
        return 0
    }
    // Chamada recursiva: soma o primeiro elemento com a soma do restante da lista
    return nums[0] + sumList(nums[1:])
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Printf("A soma da lista √© %d\n", sumList(numbers))
}
Explica√ß√£o:
Caso base: Se a lista estiver vazia, a fun√ß√£o retorna 0.

Chamada recursiva: A fun√ß√£o soma o primeiro elemento da lista com o resultado da chamada recursiva da fun√ß√£o com o restante da lista
 (excluindo o primeiro elemento).


//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Considera√ß√µes importantes:

Caso base: Sempre deve haver um caso base para evitar que a fun√ß√£o chame a si mesma indefinidamente, o que levaria a um estouro de pilha (stack overflow).

Efici√™ncia: A recursividade pode ser menos eficiente em termos de uso de mem√≥ria e desempenho em compara√ß√£o com solu√ß√µes iterativas, especialmente para problemas que podem ser resolvidos com loops simples.

Tail Recursion: Em algumas linguagens, a recurs√£o em cauda (tail recursion) pode ser otimizada pelo compilador para evitar o aumento da pilha de chamadas. 
No entanto, Go n√£o otimiza tail recursion, ent√£o √© importante estar ciente disso ao usar recursividade em Go.

A recursividade √© uma ferramenta poderosa, mas deve ser usada com cuidado para evitar problemas de desempenho e estouro de pilha.
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


 Revisar tudo ate aqui...

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Exerc√≠cios: ninja N√≠vel 6

        na pr√°tica: exerc√≠cio

- Exerc√≠cio:
        - Crie uma fun√ß√£o que retorne um int
        - Crie outra fun√ß√£o que retorne um int e uma string
        - Chame as duas fun√ß√µes
        - Demonstre seus resultados
- Solu√ßoes: - https://go.dev/play/p/1mzdeW_r7sI


Revis√£o:
Fun√ß√µes!
Servem para abstrair c√≥digo
E para reutilizar c√≥digo
A ordem das coisas √©:
func (receiver) identifier (parameters) (returns) { code }
Par√¢metros vs. argumentos
Fun√ß√µes vari√°dicas
//////////////////////
M√∫ltiplos par√¢metros

Em programa√ß√£o, par√¢metros e argumentos s√£o conceitos relacionados, mas t√™m significados distintos. 
Vamos esclarecer a diferen√ßa entre eles:

//Par√¢metros

O que s√£o?
Par√¢metros s√£o as vari√°veis listadas na defini√ß√£o de uma fun√ß√£o. 
Eles representam os valores que a fun√ß√£o espera receber quando for chamada.

Onde s√£o definidos?
Na assinatura da fun√ß√£o, entre par√™nteses ().

Para que servem?
Eles atuam como "placeholders" (espa√ßos reservados) para os valores que ser√£o passados √† fun√ß√£o.

Exemplo em Go:


func soma(a int, b int) int {
    return a + b
}
Aqui, a e b s√£o par√¢metros da fun√ß√£o soma. Eles s√£o do tipo int.

//Argumentos

O que s√£o?
Argumentos s√£o os valores reais passados para a fun√ß√£o quando ela √© chamada.

Onde s√£o usados?
Na chamada da fun√ß√£o, substituindo os par√¢metros definidos.

Para que servem?
Eles fornecem os dados que a fun√ß√£o vai processar.

Exemplo em Go:


resultado := soma(3, 5)
Aqui, 3 e 5 s√£o argumentos passados para a fun√ß√£o soma. Eles substituem os par√¢metros a e b durante a execu√ß√£o.

Diferen√ßa resumida

Par√¢metros	Argumentos

Definidos na assinatura da fun√ß√£o.	Passados na chamada da fun√ß√£o.

S√£o vari√°veis.	S√£o valores reais.

Atuam como espa√ßos reservados.	Fornecem os dados para a fun√ß√£o.

Exemplo completo
Aqui est√° um exemplo completo em Go para ilustrar a diferen√ßa:


package main

import "fmt"

// Fun√ß√£o com par√¢metros
func saudacao(nome string, idade int) {
    fmt.Printf("Ol√°, %s! Voc√™ tem %d anos.\n", nome, idade)
}

func main() {
    // Chamada da fun√ß√£o com argumentos
    saudacao("Jo√£o", 30)
}
Par√¢metros: nome string e idade int (definidos na fun√ß√£o saudacao).

Argumentos: "Jo√£o" e 30 (passados na chamada da fun√ß√£o).

Dicas importantes
Ordem dos argumentos:
Os argumentos devem ser passados na mesma ordem em que os par√¢metros foram definidos.

Tipos compat√≠veis:
Os argumentos devem ser do mesmo tipo (ou compat√≠veis) com os par√¢metros definidos.

Par√¢metros vari√°dicos:
Em Go, √© poss√≠vel usar par√¢metros vari√°dicos (um n√∫mero vari√°vel de argumentos) com .... Exemplo:


func soma(numeros ...int) int {
    total := 0
    for _, num := range numeros {
        total += num
    }
    return total
}
Em resumo, par√¢metros s√£o as vari√°veis que a fun√ß√£o espera, enquanto argumentos s√£o os valores reais passados para a fun√ß√£o. 
Ambos s√£o essenciais para o funcionamento das fun√ß√µes em Go e em outras linguagens de programa√ß√£o.
////////////////////

M√∫ltiplos argumentos
Voc√™ pode definir uma fun√ß√£o com v√°rios par√¢metros, cada um recebendo um argumento espec√≠fico.
Par√¢metros expl√≠citos: Defina cada par√¢metro individualmente.

Par√¢metros vari√°dicos: Use ... para aceitar um n√∫mero vari√°vel de argumentos.

Slice como argumentos vari√°dicos: Passe um slice usando ... .

M√∫ltiplos retornos: Retorne mais de um valor de uma fun√ß√£o.

Structs: Agrupe argumentos relacionados em uma struc
//////////////////

M√©todos
Interfaces & polimorfismo
Defer
"Deixa pra depois!"
Returns
M√∫ltiplos returns
Returns com nome (bl√©!)
Funcs como express√µes
Atribuindo uma fun√ß√£o a uma vari√°vel
Callbacks
Passando uma fun√ß√£o como argumento para outra fun√ß√£o
Closure
Capturando um scope
Vari√°veis declaradas em scopes externos s√£o vis√≠veis em scopes internos
Recursividade
Uma fun√ß√£o que chama a ela mesma
Fatoriais 


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


ex 02 -  Crie uma fun√ß√£o que receba um par√¢metro vari√°dico do tipo int retorne a soma de todos os ints recebidos;
 
        - Passe um valor do tipo slice of int como argumento para a fun√ß√£o;

        - Crie outra fun√ß√£o, esta deve receber um valor do tipo slice of int e retornar a soma de todos os elementos da slice;

        - Passe uma valor do tipo slice of int como argumento para a fun√ß√£o.

- solu√ß√£o:  eu fiz - https://go.dev/play/p/Op0RuhgtFKf

DeepSeek Exemplo - https://go.dev/play/p/t2_rlXve5im



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


ex 03 - Utilize a declara√ß√£o defer da maneira que demonstre que sua execu√ß√£o s√≥ ocorre ao final do contexto ao qual ela perten√ße

 - solu√ß√£o: - https://go.dev/play/p/S6pepA3JTb8


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

 ex 04 - Crie um tipo struct "pessoa" que contenha os campos:
        - nome
        - sobrenome
        - idade
- Crie um m√©todopara "pessoa" que demonstre o nome completo e a idade;
- Crie um valor de tipo "pessoa";
- Utilize o m√©todo criando para demonstrar esse valor.

-solu√ß√£o: -https://go.dev/play/p/FviPgjBYt19



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

 ex 05

Crie um tipo "quadrado"
Crie um tipo "c√≠rculo"
Crie um m√©todo "√°rea" para cada tipo que calcule e retorne a √°rea da figura

√Årea do c√≠rculo: 2 * œÄ * raio
√Årea do quadrado: lado * lado

Crie um tipo "figura" que defina como interface qualquer tipo que tiver o m√©todo "√°rea"
Crie uma fun√ß√£o "info" que receba um tipo "figura" e retorne a √°rea da figura
Crie um valor de tipo "quadrado"
Crie um valor de tipo "c√≠rculo"
Use a fun√ß√£o "info" para demonstrar a √°rea do "quadrado"
Use a fun√ß√£o "info" para demonstrar a √°rea do "c√≠rculo"
Solu√ß√£o:  https://go.dev/play/p/162uGww4gNG





xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

 ex 06


Crie e utilize uma fun√ß√£o an√¥nima.
Solu√ß√£o: https://go.dev/play/p/ZdM_fDiygLG



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

 ex 07

 Atribua uma fun√ß√£o a uma vari√°vel.
Chame essa fun√ß√£o.
Solu√ß√£o: https://go.dev/play/p/guI4aJ77PH9


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 ex 8

 Crie uma fun√ß√£o que retorna uma fun√ß√£o.
Atribua a fun√ß√£o retornada a uma vari√°vel.
Chame a fun√ß√£o retornada.
Solu√ß√£o: https://play.golang.org/p/A74rufv6Rs


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 ex 9

Callback: passe uma fun√ß√£o como argumento a outra fun√ß√£o.
Solu√ß√£o: https://go.dev/play/p/k2SQb4toixW


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 ex 10

 Demonstre o funcionamento de um closure.

 Em Go, n√£o temos closures no mesmo sentido que em linguagens como JavaScript ou Python,
 mas podemos simular um comportamento semelhante usando fun√ß√µes an√¥nimas e capturando vari√°veis do escopo externo

 - crie uma fun√ß√£o que retorna outra fun√ß√£o, onde esta outra fun√ß√£o faz uso de uma vari√°vel alem de seu scope.
Solu√ß√£o: https://go.dev/play/p/zLD02vOFMQl

outro exemplo so pelo main()- https://go.dev/play/p/qJUv_fNfosT

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

